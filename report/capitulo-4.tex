\chapter{System Description and Implementation}
% Os titulos dados aos capítulos são meros exemplos. Cada relatório deve adequar-se ao projeto desenvolvido.
\label{chap:sys-desc}

\section{Introduction}
\label{chap4:sec:intro}
% Cada capítulo \underline{intermédio} deve começar com uma breve introdução onde é explicado com um pouco mais de detalhe qual é o tema deste capítulo, e como é que se encontra organizado (i.e., o que é que cada secção seguinte discute).
This chapter will describe the four subsystem that were developed and that
compose the entire project. As said previously the entire system consists of
four subsystems that interact with one another using the database, the intention
is to make the system behave asynchronously and this will help in the
development or upgrade of any of the components since they are not linked they
can be exchanged for others which could have better performance or efficiency.

\section{Web Service Subsystem}
\label{chap4:sec:web-sys}
% divide it in Flask subsection and Android App subsection
% The Web Service was done using the Flask micro-framework implemented in Python.
% As already said in the previous chapter this framework allows for the use of
% third-party extensions as the ones used to develop the web service API. These
% extensions are:
% \begin{enumerate}
% 	\item Flask-RESTful
% 	\item Flask-SQLAlchemy
% \end{enumerate}

% This system also can be divided into the Web Server and the Android Companion
% application. These are made using a different technology stack, Python's Flask
% and the Android Application, and because of this the communication between these
% two systems need to deploy the same communication protocol and architecture.
% This is accomplished by using the REST architecture. This is the
The Web Service will be responsible for the communication between the user and
the firewall and notification system. It is in the Web Service's API that all of
the functionality needs to be defined.

These functionalities are as follows:
\begin{enumerate}
	\item Check for notifications on the server.
	\item List the ruleset of the server
	\item Add rules to the ruleset
	\item Remove rules from the ruleset
	\item Get reports with counters
\end{enumerate}

As said in the previous chapter the Web Service will be integrated within the
Raspberry Pi and it will make use of the Flask framework. The Web Service was
developed using the REST architecture as the foundation and respecting the six
principles which qualify it as so:
\begin{enumerate}
	\item Client-Server architecture with a clear separation between the two.
	\item Stateless -- every request from the client must contain all the
		pertinent information, which includes authentication credentials, for
		example. The server should not store any session information about the
		client.
	\item Cache -- responses from the client might be chacheable or not by the
		server or intermidiate systems in order to maximing performance. These
		responses must be labeled by the server as cacheable or noncacheable.
	\item Uniform Interface -- the protocol used between the client and the
		server resources must be well defined and standardized, for exmaple the
		use of the HTTP protocol.
	\item Layered Interface -- other machines and systems might be added between
		the client and the server for reliability, scalability or performance
		reasons.
	\item Code-on-Demand -- optionally, clients can dowload and execute code
		from the server in their own context.
\end{enumerate}
(These principles were first described in Roy Fielding's Ph.D. dissertation.)

The API can be accessed using the HTTP protocol and the following types of
headers that already come with the protocol specification:
\begin{enumerate}
	\item GET
	\item POST
	\item DELETE
	\item PUT
	\item AUTHENTICATE (check for the official name for the auth header)
\end{enumerate}

% \begin{lstlisting}[caption=Trecho de código usado no projeto.]

\section{Database Subsystem}
\label{chap4:sec:db-sys}
The database can be considered the center of the entire system since it will be
where all of the data stored to represent the firewall rules as well as the
packets which were flagged by the user. It will also contain pairs of username
and password representation for the user authentication even though this only
having one user registered might be enough for this type of system.
The database management system is SQLite 3 which as already a good API provided
in the Python standard libraries, nonetheless this project will make use of a
package called SQLAlchemy that can is freely available online which abstracts
the developer from the SQL queries.

The SQLAlchemy module enables the programmer to represt all of the entities as
well as the relationships between them using Python classes that inherit from
the Model superclass provided by SQLAlchemy. This way the developer only need to
declare the name of the attributes as well as the table name by declaring them
as attributes of the classes.

The models that need to be implemented in order for the whole system to work as
intended are as follows:
\begin{enumerate}
	\item User -- representing the user's credentials, username and password
		fields.
	\item Rule -- represents a rule for the firewall system to execute.
	\item Rule_IP -- as the IP that the rule might have associated to it.
	\item Packet -- as a representation of a network packet, especially used for
		the notifications.
\end{enumerate}

These are all entities in the database and will conveil all of the data for the
application and the rest of the subsystems will all needs to routinely interact
with the database in order to get the rules for the firewall, to authenticate
users or even to get the information for the email and app notifications.

% insert and explain at least one of the models

After modelling the data we only need to create a session for the database, and
all of the data inside the database will be accessible with the call of methods
from the session instance. These methods could be insert, delete, update and
query.

% insert and explian at least one query and one insertion

% The database is the central component of our system and it is the most
% important system, because without it nothing else can run.

The database is organized with the following schema:

%insert an image of the database's schema here

% Describe each entity within the database.

\section{Email Notification Subsystem}
\label{chap4:sec:email-sys}
The Email Notification Service will act as a complement to the Android
applciation and will only send out notifications only after a certain,
user defined, amount of time of the last call to the Web Service and it will
keep doing so by deploying cycles, with a duration also defined by the user of
the system.

By making use of the \emph{email} module provided within Python's Standard
Library, it is possible to connect to an account on a SMTP server in order to
send any email, after the input of user credentials such as the email addres and
the password of that account. In the context of this project a Google Gmail
account was used to be the source of the email message and it will send emails
regularly to the user's email account with updates on the network that passes
through the gateway before heading to the Internet.

% last thing!!!
% The Email Notification service will be keep notifying the user whenever he isn't
% at home, this is a measure of securing the local network, but it would also need
% a server to which both the gateway device and a possible mobile application
% would need to connect in order to make communication possible.

% Through email it will be easier for the device to simply send messages of what
% is happening with the devices inside their domestic network. If there are any
% flagged communitcations are performed then this subsystem will inform within
% regular, user defined, intervals of time, e.g. every two hours send a report if
% any activity, signalled by the user as note-worthy, has occured.

% As referred before this will be a complement for the Android notifications
% because this will only occur whenever the user is not home, this is all done by
% logging when the last request to the web service preventing that both the email
% and Android notifications to overlap.

% Using the \emph{email} module present in the Python standard library it was
% possible to connect to an SMTP server like Googles gmail and after providing
% access credentials, username and password, the system can now send emails for a
% specified email address.

\section{Firewall Handler Subsystem}
\label{chap4:sec:firewall-sys}
The Firewall Subsytem consists of the firewall itself, which will be
accomplished using the \emph{iptables} system, present in most Linux
distributions as the default firewall system, and there is also a firewall
handling system that is responsible for acquiring the rules, defined by the
user, from the database and deploying them on the firewall system.

\subsection{iptables}
\label{chap4:sec:firewall-sys:sub:iptables}
The iptables is an application program that allows for the configuration of the
Linux kernel firewall, which uses the Netfilter framework. This application,
provided in most Linux distributions, is an interface that enables users to
set up, maintain and inspect the tables of IP packet filtering rules within the
Linux kernel.

It is a widely used and very flexible system used by system administrators that
need to enforce certain security policies on a single system or network. There
are two versions of this software, one for IPv4 and another one for IPv6, the
latter being named iptables6.

\subsection{python-iptables}
\label{chap4:sec:firewall-sys:sub:iptc}
The \emph{python-iptables} is a package that makes the interface between
iptables and Python scripts. By using this package we could create the firewall
handling class that will interact with the Linux kernel firewall and employ the
rules using the Python language.
This Python package makes the process of deploying rules to the firewall easier
as well as the addition of new rule chains for the filtering within the tables.

The Firewall class does just that, querying all of the rules inside the
database, looking for optional source and destination IP addresses for any given
rule and implementing the pretended actions.
The main cycle of the class is the \emph{run()} method that will perform the
following task within an infinite loop:

\begin{enumerate}
	\item Get a list of rules from the DB;
	\item Flush the rules within the iptables ruleset;
	\item Insert the new rules;
	\item Wait for the refresh time to pass and start again.
\end{enumerate}

Some optimizations are also present, for example there is a match made by the
system in order to check if the ruleset from the DB is the same of the previous
iteration, or disabling the autocommit for each rule in order to deploy the
entire ruleset right after flushing instead of flushing the entire ruleset and
adding a rule at a time.

% Add the Firewall().run() method here!

\section{Conclusions}
\label{chap4:sec:concs}
This chapter described all of the subsystems that comprise the project. We
talked about the Web Service with the Flask server and also the Android app that
consumes it. We also described the Database system which is the central
component and all systems depend on it. We referred the Email Notification and
the details that need to be in place to make email notifications possible. At
last we described how the Firewall subsystem and how we accomplished the sense
of dynamic firewall configuring.
