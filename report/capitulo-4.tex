\chapter{System Description and Implementation}
% Os titulos dados aos capítulos são meros exemplos. Cada relatório deve adequar-se ao projeto desenvolvido.
\label{chap:sys-desc}

\section{Introduction}
\label{chap4:sec:intro}
% Cada capítulo \underline{intermédio} deve começar com uma breve introdução onde é explicado com um pouco mais de detalhe qual é o tema deste capítulo, e como é que se encontra organizado (i.e., o que é que cada secção seguinte discute).
Within this chapter there will be a detailed description of the various
subsystems of this project. The design was inspired by the Microservice
architecture which is the new trend in architecture, especially in the
development of web applications.
This type of architecture design allows the division and modularization of
complex systems by grouping all the functionality into various services which
will then be called only when requested. This is good from a developer's
perspective because it enables the division all the moving parts necessary to
make the system run as expected and it also allows the individual development of
these subsystems that can run independently from all the other systems.

% older version of the intro below
This chapter will describe the four subsystem that were developed and that
compose the entire project. As said previously the entire system consists of
four subsystems that interact with one another using the database, the intention
is to make the system behave asynchronously and this will help in the
development or upgrade of any of the components since they are not linked they
can be exchanged for others which could have better performance or efficiency.

\section{Web Service Subsystem}
\label{chap4:sec:web-sys}

The Web Service is be responsible for all the communication between the user and
the Raspberry Pi components. The web service will be all implemented making use
of the \emph{Flask} framework allied with the \emph{flask-restful} extension
that enables the declaration of resources to be accessed through the Hyper Text
Transfer Protocol (HTTP) requests.

In order to implement each resource we only need to create a class to represent
each Uniform Resource Identifier (URI). These resources will need the methods
for GET, POST, PUT and DELETE requests and these can be declared as method names

These functionalities are as follows:
\begin{enumerate}
	\item Check for notifications on the server.
	\item List the ruleset of the server
	\item Add rules to the ruleset
	\item Remove rules from the ruleset
	\item Get reports with counters
\end{enumerate}

As said in the previous chapter the Web Service will be integrated within the
Raspberry Pi and it will make use of the Flask framework. The Web Service was
developed using the REST architecture as the foundation and respecting the six
principles which qualify it as so:
\begin{enumerate}
	\item Client-Server architecture with a clear separation between the two.
	\item Stateless -- every request from the client must contain all the
		pertinent information, which includes authentication credentials, for
		example. The server should not store any session information about the
		client.
	\item Cache -- responses from the client might be chacheable or not by the
		server or intermidiate systems in order to maximing performance. These
		responses must be labeled by the server as cacheable or noncacheable.
	\item Uniform Interface -- the protocol used between the client and the
		server resources must be well defined and standardized, for exmaple the
		use of the HTTP protocol.
	\item Layered Interface -- other machines and systems might be added between
		the client and the server for reliability, scalability or performance
		reasons.
	\item Code-on-Demand -- optionally, clients can dowload and execute code
		from the server in their own context.
\end{enumerate}
(These principles were first described in Roy Fielding's Ph.D. dissertation.)

The API can be accessed using the HTTP protocol and the following types of
headers that already come with the protocol specification:
\begin{enumerate}
	\item GET
	\item POST
	\item DELETE
	\item PUT
	% \item AUTHENTICATE (check for the official name for the auth header)
\end{enumerate}

The web service will communicate using JSON for data structuring enabling the
independence of programming language for the web service and the applications
that will interact with the user and the web service itself.

The API for this RESTful web service is as follows:
\begin{enumerate}
	\item "rule/<int:id>" -- making it available for the client to check for a
		specific rule, as well as delete or edit it, using the GET, DELETE and
		PUT requests, respectively, from the HTTP protocol.
	\item "/rules" -- this URI will enable the client application to request for
		the full set of rules currently running on the server, by using the GET
		request. By making a request with the POST type the client application
		can append new rules to the rule set already in place, which will then
		be updated during the next cycle of the firewall subsystem.
	\item "/counter/<int:id>" -- URI that will only be accessed through GET
		request and provided with the id of the rule it will deliver the
		counters value, with number of packets and total number of bytes that
		were matched with that rule.
	\item "/counters" -- also only accessible through GET requests and sends the
		list of every counter for every rule in place, with their respective
		packets and number of bytes.
\end{enumerate}

% TALK ABOUT THE FIELDS OF THE flask-restful

\section{Database Subsystem}
\label{chap4:sec:db-sys}
The database can be considered the center of the entire system since it will be
where all of the data stored to represent the firewall rules as well as the
packets which were flagged by the user. It will also contain pairs of username
and password representation for the user authentication even though this only
having one user registered might be enough for this type of system.
The database management system is SQLite 3 which as already a good API provided
in the Python standard libraries, nonetheless this project will make use of a
package called SQLAlchemy that can is freely available online which abstracts
the developer from the SQL queries.

The SQLAlchemy module enables the programmer to represt all of the entities as
well as the relationships between them using Python classes that inherit from
the Model superclass provided by SQLAlchemy. This way the developer only need to
declare the name of the attributes as well as the table name by declaring them
as attributes of the classes.

The models that need to be implemented in order for the whole system to work as
intended are as follows:
\begin{enumerate}
	\item User -- representing the user's credentials, username and password
		fields.
	\item Rule -- represents a rule for the firewall system to execute.
	\item Rule\_IP -- as the IP that the rule might have associated to it.
	\item Packet -- as a representation of a network packet, especially used for
		the notifications.
\end{enumerate}

These are all entities in the database and will conveil all of the data for the
application and the rest of the subsystems will all needs to routinely interact
with the database in order to get the rules for the firewall, to authenticate
users or even to get the information for the email and app notifications.

% insert and explain at least one of the models

After modelling the data we only need to create a session for the database, and
all of the data inside the database will be accessible with the call of methods
from the session instance. These methods could be insert, delete, update and
query.

% insert and explian at least one query and one insertion

% The database is the central component of our system and it is the most
% important system, because without it nothing else can run.

The database is organized with the following schema:

%insert an image of the database's schema here

% Describe each entity within the database.

\section{Email Notification Subsystem}
\label{chap4:sec:email-sys}
The Email Notification Subsystem will act as a complement for the Android
application, which means that it will only send out notifications to the user if
he isn't home. In order to detect the user, the Email Service queries the
database to check when was the last time the user was making requests to the Web
Service API, then calculates the time elapsed and if it's greater or equal to
the cycle period it will send an email with a small report about the network
traffic made inside the local network. It will then simply sleep until the next
cycle repeating the process. This cycle time will be defined by the user when he
initially configures the system in the Raspberry Pi.

The user will need to define the email address where he wants to receive the
notifications as well as the cycle periods, i.e., the time that needs to pass
between notifications sent to the users email, lastly the user will also be
asked to provide his first name in order for the system to address the user
properly.

The email being sent to the user is built using a template that is formatted
according to JSON standards which makes it highly customizable if the user
actually wants to modify some of the fields. The following code listing
demonstrates a typical template, the default template provided within the
installation files. During configuration, especially if the user uses the easy
configuration scrip some of these fields will suffer changes, both the
users\_email and the users\_name will be changed accordingly in this template
file after configuration.

The email service will also be in charge of creating the small reports that go
in the reason field, which is the body of the email per se. This is all done
automatically by the \emph{mixRuleCounters(. ,.)} which takes as parameters the
rules and counters received from the database. The method will then iterate
through all of the rules which have \emph{NOTIFY} or \emph{NOTIFY\_BLOCK} as
actions and link them with the counters for those rules.

Since the system needs to be clear for the user, all of the rules are explicitly
converted into a more user friendly format and then they will be united with the
values for the counters at a specific time.

% put a small template of the email as a code listing.

The emails being sent will all have the same design which is defined in the a
JSON formatted file named, \emph{email.json}. The Email Service will compose the
email for the user based on this template changing the various fields according
to the information that the user gave during initial configuration.

\begin{lstlisting}[caption=Example of the email JSON template.]
{
    "email": {
        "users\_name": "Gustavo Gomes",
        "sign": "Sent From Heimdall Secure Gateway.",
        "goodbye": "Thank you for your attention,",
        "subject": "Notification From Heimdall Secure Gateway",
        "reason": "Testing this email thingie",
        "email\_to": "gustaafewf",
        "greeting": "Hello there Mr/Mrs"
    }
}
\end{lstlisting}

A problem found with this feature was that the email system globally has become
much more secure and it is impossible to send an email without an Email Provider
which will also imply that the user would need to purchase or get a domain name
in order to make this feature possible, the solution found for this problem was
to create an email account that will have all the credentials and be prepared to
be accessed by this subsystem, using the email address and the password of that
account and connecting via a TLS connection to the email provider, which in this
case is Google's Gmail. By doing this it is possible to send out emails to the
user's specified account from that account created for the system.

By making use of the \emph{email} module provided within Python's Standard
Library, it is possible to connect to an account on a SMTP server in order to
send any email, after the input of user's credentials such as the email address
and the password of that account.

% last thing!!!
% The Email Notification service will be keep notifying the user whenever he isn't
% at home, this is a measure of securing the local network, but it would also need
% a server to which both the gateway device and a possible mobile application
% would need to connect in order to make communication possible.

% Through email it will be easier for the device to simply send messages of what
% is happening with the devices inside their domestic network. If there are any
% flagged communitcations are performed then this subsystem will inform within
% regular, user defined, intervals of time, e.g. every two hours send a report if
% any activity, signalled by the user as note-worthy, has occured.

% As referred before this will be a complement for the Android notifications
% because this will only occur whenever the user is not home, this is all done by
% logging when the last request to the web service preventing that both the email
% and Android notifications to overlap.

% Using the \emph{email} module present in the Python standard library it was
% possible to connect to an SMTP server like Googles gmail and after providing
% access credentials, username and password, the system can now send emails for a
% specified email address.

\section{Firewall Interface Subsystem}
\label{chap4:sec:firewall-sys}
The Firewall Subsystem is the one component responsible for the management and
deployment of rules inside the firewall, iptables. The only concern for this
system is to deploy the rules from the database and the accounting for the
network traffic of those same rules. First we will talk about the
\emph{python-iptables}, or \emph{iptc} package, which enables the direct
interaction between this system and the firewall system, which was described in
a previous chapter, the \emph{iptables}. Then a description of the class that
manipulates and handles both the rules and their corresponding counters is
described as well as the processes involved with the data retrieval from the DB
and conversion.

\subsection{python-iptables}
\label{chap4:sec:firewall-sys:iptc}
The \emph{python-iptables} is a third party package that can be found in the
Python Package Index (PyPI), and is provides a direct link to the
\emph{iptables} firewall system. This is acomplished because this module is a
Python wrapper around the \eph{libiptc} which is a C library that provides the
programming interface for the \emph{iptables}.

Some of the features of this module is the capability to connect to any single
one of the tables already provided by the \emph{iptables} as well as any chain
within those tables. As said previously, \emph{iptables} groups the rules within
chains which are also grouped inside different tables.

This module enables the connection to any given table and chain and the direct
manipulation of the rules within it. The rules can be deleted and added as  well
as modified without ever needing to restart the firewall system. The rules
temselves are also able to be modified to have all the same level of detail as
they have when declared inside the \emph{iptables}, which may include:
\begin{enumerate}
	\item Target declaration;
	\item Protocol definition;
	\item Port speficication;
	\item IP filtering, which includes IP ranges;
	\item MAC address filtering;
	\item Pattern matching.
\end{enumerate}

For the context of the project described within this document only the first
five functions are used, with special attention to the IP filtering which won't
involve any IP ranges, all the other functionalities mentioned are used.

These functionalities will be talked about during the next section where we will
describe the class created, which the primary goal is to convert and update the
set of rules according to the ones specified in the database.

\subsection{Firewall Class}
\label{chap4:sec:firewall-sys:firewall-class}
There is a Firewall object that can be configured with the chains defined on
\emph{iptables}, this can be accomplished by setting defining the named optional
parameter when initializing a Firewall object, it also defaults to the 'FORWARD'
chain in the \emph{iptables} system which is the one that this subsystem needs
to interact with. It will always connect to the \emph{FILTER} table of
\emph{iptables} since this is the table that filters all of the traffic passing
through the machine, i.e. the Raspberry Pi.

Since the entire system is modular the Firewall class can be used independently
from the system itself. Of course it is still recommended that it should be
paired at least with the database since it has methods to query a database using
a \emph{SQLAlchemy} session.

The methods that are provided in this class are the following:
\begin{enumerate}
	\item addRule() -- method that handles the conversion of rules inside the
		database model object to \emph{python-iptables} rule objects.
	\item submitRule(.) -- handles the submission of the rule to the database,
		if the table from the database has the autocommit feature as False then
		it will simply add the rule but not commit it to the working firewall
		rule set.
	\item flushRules() -- responsible for flushing all of the rules from
		the chain.
	\item resetCounters() -- method that will reset the counters for all of the
		rules in the \emph{iptables}, as well as the data inside the database.
		This is used when the rules change because the counters need to start
		from zero and the database needs to be cleaned from the old rule set.
	\item ruleUpdate() -- main cycle for this subsystem, which gets the rules
		from the database, converts them from the models inside the database to
		\emph{iptables} compliant rules, resets the counters and adds the rules
		to the chain before ever commiting them to the firewall itself.
	\item createRule(.) -- creates an \emph{iptables} rule using a dictionary
		instead of an instance of the database models.
	\item counterUpdate() -- updates the counters inside the database, since the
		counters aren't dynamic per se, the table of the firewall needs to be
		refreshed in order to update the values of the counters. This will then
		publish the results in the database.
	\item counterDB(.) -- method that receives the results of the counters and
		connects them to each rule, afterwards sending it all to the database,
		by converting the data into a database model object.
	\item run(wait\_time) -- main method that will run both the ruleUpdate()
		method as well as the counterUpdate() to always keep the rules tracked
		and equal to the ones on the database. The \emph{wait\_time} param
		defaults to 30 and it is the periodicity of the cycle, in seconds.
\end{enumerate}

The Firewall Subsytem consists of the firewall itself, which will be
accomplished using the \emph{iptables} system, present in most Linux
distributions as the default firewall system, and there is also a firewall
handling system that is responsible for acquiring the rules, defined by the
user, from the database and deploying them on the firewall system.

\section{Android Companion App}
\label{chap4:sec:android}
In order to make it a complete system an Android mobile application was
conceived that mostly allows the user to interact with the Web Service's API.
The requests to the web service are made using the Volley as well as the
HTTPClient, since the Web Service only provides the API via HTTPS and with
authentication, the HTTPClient is required to handle the self-signed certificate
provided with the application as well as take care for the HTTPBasic
authentication headers.

As already said when describing the Web Service all of the data transmitted over
the network needs to be in the JSON format in order to provide a standard way of
communicating with all the client devices.

The aplication will irst ask the user to provide the authentication credentials
as well as the gateway's IP address.

% insert the authentication print

There are some classes defined to help structure all of the data and to allow
for some organization and manipulation of the data that can be received by the
Web Service. These classes are the Rule, Ip and Mac classes.

The activities that are provided by the application are presented in the
following list:
\begin{enumerate}
	\item AddRule -- Activity to append a rule at the end of the rule set on the
		server, uses the POST request;
	\item EditRule -- Used to edit a rule that is already implemented, making
		use of the PUT request method.
	\item DeleteRule -- Small activity that handles the DELETE request for a
		specific rule;
	\item ListRules -- Activity to list and access all of the rules that are in
		the system.
\end{enumerate}

All of these activities make use of the \emph{JSONObject} data type enabling
both the interpretation and the creation of the data structures to be sent over
the network into and from the Web Service, running on the Raspberry Pi.

\section{Conclusions}
\label{chap4:sec:concs}
This chapter described all of the subsystems that comprise the project. We
talked about the Web Service with the Flask server and also the Android app that
consumes it. We also described the Database system which is the central
component and all systems depend on it. We referred the Email Notification and
the details that need to be in place to make email notifications possible. At
last we described how the Firewall subsystem and how we accomplished the sense
of dynamic firewall configuring.
