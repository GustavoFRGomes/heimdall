\chapter{System Architecture and Requirement Analysis}
% Os titulos dados aos capítulos são meros exemplos. Cada relatório deve adequar-se ao projeto desenvolvido.
\label{chap:sys-arch}

\section{Introduction}
\label{chap3:sec:intro}
This chapter focuses on software engineering with section 3.2 being a brief
requirement analysis for the system, followed a section describing the approach
to the system architecture, and then section 3.4 will focus on introducing the
tools that were leveraged in the implementation.

\section{Brief Requirement Analysis}
\label{chap3:sec:reqs}

This section will list both the function and non-functional requirements for the
system.

\subsection{Functional Requirements}
\label{chap3:sec:reqs:func}
The functional requirements for the system are comprised within the following
list:
\begin{enumerate}
	\item The system shall allow the user to add rules to the gateway firewall;
	\item The system shall allow the user to delete rules in the gateway
		firewall;
	\item The system shall allow the user to edit rules in the gateway's
		firewall;
	\item The system shall allow the user to list all the rules inside the
		gateway's firewall;
	\item The system shall allow the user to authenticate with the gateway
		application;
	\item The system shall allow the user to access the information of a rule in
		the gateway's firewall;
	\item The system shall allow the user to access all the packets that match a
		rule in the gateway's firewall;
	\item The system shall allow the user to access all the bytes that match a
		rule in the gateway's firewall;
	\item The system shall allow the user to add credentials on the gateway;
	\item The system shall allow the user to delete all user credentials stored
		in the gateway;
	\item The system shall allow the user to get the amount of packets for a
		specific rule;
	\item The system shall allow the user to get the amount of bytes for a
		specific rule;
	\item The system shall allow the user to add a notifications email;
	\item The system shall send traffic reports to the user's email;
\end{enumerate}

\subsection{Non-functional Requirements}
\label{chap3:sec:reqs:non-func}
\begin{enumerate}
	\item The system shall be divided using a Client-Server architetcure;
	\item The application shall only generate one database in the server-side;
	\item The application shall only allow for user registration on the
		server-side;
	\item The server-side component shall be divided into independent
		compontents;
	\item The server-side system shall comprise a RESTful web service;
	\item The server-side system shall comprise a Firewall service;
	\item The server-side system shall have an Email service to notify the user;
\end{enumerate}

\section{Architecture}
\label{chap3:sec:arch}
% Diagrama de Componentes
For this system there are two types of architecture being used, one is the
typical client-server architecture because it has the Android Companion
Application as the client and the system with which the application will
interact running on the Raspberry Pi, which is the server-side of the whole
system.

The server-side architecture was inspired by the
Microservices architecture being adopted in the Web Development are, which state
that a system should be divided into services that are independent from each
other in terms of execution and that each one of these services should only do
one single task or deal with one single component. This is reflected in the way
the server-side system was built being "database centric", i.e. each component
will interact solely with the database and not with each other preventing
concurrency issues upfront. The Raspberry Pi will then have the following
subsystems:
\begin{enumerate}
	\item Database;
	\item Web Service;
	\item Email Notifaction;
	\item Firewall Interface.
\end{enumerate}

This architecture desing also enables the interchangeability of the server-side
components actually making it possible to implement alternatives for each of the
components and making them run without comprimising any of the other subsystem,
which makes it possible for the user or another developer to swap, for example,
the Email Notification with a Short Messaging Service (SMS) notification system
or the Firewall Interface with a new system that he or she implemented.

These distinct subsystems will be described in the next chapter, alongside the
description of the Android application.

% say database-centric?

\section{Tools}
\label{chap3:sec:tools}
In order to make the entire system feasable in the proposed timeframe there was
the need to use already available tools both in the Linux Operating System and
also on the Android

\subsection{Volley}
\label{chap3:sec:tools:sub:volley}
The Volley package is present in the standard library of Android it is
compatible with the first Android versions of the Operating System, and it helps
the developer to implement a queue of HTTP requests for various URL defined
resources.

This is a great tool for the development of web service consumers, making the
process of sending and receiving requests and responses with both text strings
or with JSON content. This package also helps the developer handle error
messages that might be received as a response from the web service.

\subsection{Flask}
\label{chap3:sec:tools:sub:flask}
\emph{Flask} is a micro-framework for the development of web applications. It
was designed as an small yet extensible framework providing a solid core with
basic services as:
\begin{enumerate}
	\item routing;
	\item debugging;
	\item Web Server Gateway Interface (WSGI);
	\item Template Support.
\end{enumerate}

The main objective with this framework is to avoid any features that might be
unnecessary for any of the developers. In order to make up for this lack of
functionality there is a support for extensions that can amplify these
funcionalities as, for example, authentication, development of web services and
database access. It is up to the developer to choose the extensions they might
need or even implement their own ones.
\emph{Flask} has two main dependencies, which can be divided into \emph{Jinja2} for
template support and \emph{Werkzeug} for the rest of the services mentioned
above.

In the context of this software project the \emph{Flask} framework will be the
foundation of the web service, which will run on the Raspberry Pi, alongside the
email notification, database and firewall interface service. In order to develop
the web service to interact with the Android application there was the
integration of the following extensions:
\begin{enumerate}
	\item flask-sqlalchemy -- to work with the database and its data models.
	\item flask-restful -- for the development of the API structure using the
		REST principles.
	\item flask-httpauth -- to enable the authentication of the users accessing
		the Web API.
\end{enumerate}

% \subsection{SQLite}
% \label{chap3:sec:tools:sub:sqlite}
% The database handling is through the use of the another Python module named
% SQLAlchemy which abstracts the developer from the SQL query language by using
% Python classes to model the SQLite 3 database entities, and also query methods
% for each class that allow the programmer to query and filter the results within
% the database through Python methods.

% The SQLite was the chosen RDBM due to it's low computational resource
% requirements. This databae has a cap of data at 3TB which is more then suficient
% for the purposes of this project.

\subsection{SQLAlchemy}
\label{chap3:sec:tools:sub:sqlalcemy}
SQLAlchemy is a library used to interact with the different SQL databases
available. This modules allows the conversion of the data within the database to
Python objects representing the models for each table. This library is a third
party module, not included in the Python Standard Libraries, that was created by
Mike Bayer in 2005.

This library is widely adopted within the Python developer universe because it
simplifies the access and manipulation of data inside a database. It supports
some of the most common database systems as, for example:
\begin{enumerate}
	\item Postgres
	\item MySQL
	\item SQLite
	\item Oracle
\end{enumerate}
By using this library a developer could abstract the code from the underlying
database and its SQL peculiarities. It also helps with the sanitization of the
data which is inputed to the database preventing common security flaws like SQL
injection attacks.

SQLAlchemy also provides flexibility by having two alternative modes of usage,
which could be used interchangeably depending on the personnal preferences of
the developer, these two distinct ways are:
\begin{enumerate}
	\item SQL Expression Language also known as Core -- is mostly a Pythonic way
		of representing common SQL statements and expressions with almost no
		abstraction from typical SQL language. This is also the foundation of
		the next usage mode.
		% ORM - Object Relational Mapper
	\item ORM -- has a more high-level abstraction and leveraging a declarative
		system that enables the developer to work in a more idiomatic way. This
		is accomplished by binding the database schema with data models
		represented as Python classes.
\end{enumerate}

This project makes extensive use of the SQLAlchemy's ORM mode with a SQLite3
database system.

\subsection{iptables}
\label{chap3:sec:tools:sub:iptables}
The iptables is known as the default firewall system deployed in almost all
GUN/Linux distributions. This firewall system enables the declaration of chains
for complex chains of events that can go from log appending as well as accepting
or blocking packets.

The iptables works by interacting withe the packet filtering hooks provided by
the Netfilter framework, which is present within the GNU/Linux kernel.
This firewall system also allows the interception of packets in various stages
of their traversal through the network card, due to the hooks from the Netfilter
framework. These built-in chains and their
respective hooks are as follows:
\begin{enumerate}
	\item PREROUTING -- NF\_IN\_PRE\_ROUTING
	\item INPUT -- NF\_IN\_LOCAL\_IN
	\item FORWARD -- NF\_IP\_FORWARD
	\item OUPUT -- NF\_IP\_LOCAL\_OUT
	\item POSTROUTING -- NF\_IP\_POST\_ROUTING
\end{enumerate}

In order to interact with iptables on the Raspberry Pi, the system makes use of
\emph{python-iptables} which is an extension module that makes a brigde between
iptables and the Python programming language.
This module makes use of Python objects to perform all the functionality for the
firewall, including interacting and defining:
\begin{enumerate}
	\item Chains;
	\item Tables;
	\item Rules;
\end{enumerate}

The iptables application has the following four tables: (1) FILTER; (2) MANGLE;
(3) RAW; (4) not sure. These tables allow for different purposes, and for the
scope of this project only the \emph{FILTER} table is important, since the
primary objective of the system being developed is to filter packets and
connections according to rules established by the user.

Python-iptables, also known as \emph{iptc}, allows the deveolper to access and
interact with the firewall system for any of the aforementioned Tables, and
allows the creation and management of the Chains within these tables.

The iptables Chains are sets of rules that can be invoked whenever a packet
matches the rules within that chain, iptables also provides three different
predefined Chains which are:
\begin{enumerate}
	\item \emph{INPUT} -- for all packages that have as host the machine to
		which they arrive;
	\item \emph{FORWARD} -- covers all the network traffic that isn't destinted
		nor originated from the machine in question;
	\item \emph{OUTPUT} -- is the chain that handles all the traffic generated
		by the host.
\end{enumerate}

Since the main functionality of this project is to filter traffic that is
passing through the gateway, the main Table and Chain that will be used are
FILTER and FORWARD, respectively.

\section{Conclusions}
\label{chap3:sec:concs}
In this chapter we have talked about the underlying architecture of the system
as well as the tools that were used in the various components of the project.
We refer the Volley used by the mobile application to request resources from the
Flask web service running a REST API. We also talked about the databate
management system as well as the SQLAlchemy Python module. We ended this chapter
by talking about the iptables firewall system present in GNU/Linux which will be
used as the firewall on the Raspberry Pi gateway.
